## 2026-02-07 学習実績

### 📚 完了タスク
- [x] The Odin Project: JavaScript Course "Project: Library"
- [x] 書籍削除機能の実装（配列操作とDOM更新の連携）
- [x] 既読/未読ステータスのトグル機能実装（プロトタイプ活用の実践）

### 💡 学びのポイント
**新規習得：**
- **UUIDの活用 (`crypto.randomUUID()`):** 配列のインデックス（`index`）をIDとして使うと、削除時に番号がずれてバグの原因になることを回避するため、一意のIDを生成してオブジェクトに持たせる手法を習得。
- **`filter()` メソッドによる削除:** `splice` で要素を切り取るのではなく、条件に合わない（削除対象以外の）要素だけで新しい配列を作ることで、安全にデータを更新する方法。

**理解深化：**
- **Prototypeメソッド:** `Book.prototype.toggleRead` を定義することで、すべてのBookインスタンスがメモリを節約しつつ共通の機能を継承する仕組みを実装レベルで理解。
- **DOMとデータの結合:** `card.dataset.id = book.id` や、ボタンの `onclick` イベント内で特定の `book` オブジェクトを参照させるクロージャ的な使い方により、画面上の操作と内部データをリンクさせる感覚。

**トラブルシューティング：**
- **課題:** 設計段階では「IDで識別して削除した後、配列の順番がずれる問題」を懸念していた。
- **解決:** インデックス番号への依存をやめ、各Book生成時にユニークID (`crypto.randomUUID()`) を付与。削除時はそのIDを使って `myLibrary.filter(book => book.id != id)` することで、ズレを気にせず特定要素だけを排除するロジックを確立した。

### 🔗 実装コード
- リポジトリ：https://github.com/LJDJGC/library-project-top 
- 主要コード：
```javascript
// プロトタイプを使ったメモリ効率の良いメソッド定義
Book.prototype.toggleRead = function() {
  this.isRead = !this.isRead;
};

// フィルタリングによる安全な削除ロジック
function removeBook(id) {
  // 指定したID以外の本だけを残す（＝指定IDを削除）
  myLibrary = myLibrary.filter(book => book.id != id);
  displayBook();
}

// 動的なボタン生成とイベントリスナーの付与
const toggleBtn = document.createElement('button');
toggleBtn.onclick = () => {
  book.toggleRead(); // インスタンスメソッドの呼び出し
  displayBook();     // 画面の再描画
};
```

### ⏭️ Next Action
- [ ] Factory Functions and the Module Pattern のセクションへ進む（目安：45分）
- [ ] 現在の `script.js` はグローバル汚染（`myLibrary` など）があるため、次のセクションで学ぶ「モジュールパターン」を使って、コードをより安全な設計にリファクタリングする予習を行う。





## 2026-02-07 Learning Achievements

### 📚 Completed Tasks
- [x] The Odin Project: JavaScript Course "Project: Library"
- [x] Implementing a Book Deletion Feature (Integrating Array Operations and DOM Updates)
- [x] Implementing a Read/Unread Status Toggle Feature (Practicing Prototype Use)

### 💡 Key Learning Points
**New Learnings:**
- **Utilizing UUIDs (`crypto.randomUUID()`):** Learned a technique for generating unique IDs and assigning them to objects to avoid bugs caused by mismatches in array indexes (`index`) when using them as IDs.
- **Deleting with the `filter()` Method:** Instead of cutting elements with `splice`, this method safely updates data by creating a new array containing only elements that do not meet the criteria (i.e., elements not targeted for deletion).

**Deepening Understanding:**
- **Prototype Method:** By defining `Book.prototype.toggleRead`, I understood at the implementation level how all Book instances inherit common functionality while conserving memory.
- **Binding DOM and Data:** By using `card.dataset.id = book.id` and a closure-like method of referencing a specific `book` object in a button's `onclick` event, I felt like I was linking on-screen operations with internal data.

**Troubleshooting:**
- **Challenge:** During the design phase, I was concerned about the problem of the array order becoming out of sync after identifying and deleting an ID.
- **Solution:** Instead of relying on index numbers, I assigned each Book a unique ID (`crypto.randomUUID()`) when it was created. When deleting, I used that ID with `myLibrary.filter(book => book.id != id)`, establishing logic to remove specific elements without worrying about misalignment.

### 🔗 Implementation Code
- Repository: https://github.com/LJDJGC/library-project-top
- Main Code:
```javascript
// Memory-efficient method definition using prototypes
Book.prototype.toggleRead = function() {
this.isRead = !this.isRead;
};

// Safe deletion logic using filtering
function removeBook(id) {
// Keep only books with IDs other than the specified one (= Delete the specified ID)
myLibrary = myLibrary.filter(book => book.id != id);
displayBook();
}

// Dynamic button generation and event listener assignment
const toggleBtn = document.createElement('button');
toggleBtn.onclick = () => {
book.toggleRead(); // Call the instance method
displayBook(); // Redraw the screen
};
```

### ⏭️ Next Action
- [ ] Proceed to the Factory Functions and the Module Pattern section (estimated time: 45 minutes)
- [ ] Because the current `script.js` contains global pollution (e.g., `myLibrary`), prepare for the next section, where you'll learn about the "module pattern," and refactor the code to a safer design.






## 2026-02-07 学習実績

### 📚 完了タスク
- [x] The Odin Project: JavaScript Course "Project: Library"
- [x] 書籍削除機能の実装（配列操作とDOM更新の連携）
- [x] 既読/未読ステータスのトグル機能実装（プロトタイプ活用の実践）
- [x] UUID導入によるデータ整合性の確保

### 💡 学びのポイント
**新規習得：**
- **UUID (`crypto.randomUUID()`):** 配列のインデックス（`index`）をIDとして使用すると、削除時に番号がずれ、DOMとデータが不一致になるリスクがあることを学習。一意なIDを生成して管理する手法を採用。
- **`filter()` による非破壊的削除:** `splice()` で配列を切り取るのではなく、条件に合わない要素を除外して新しい配列を作ることで、安全にデータを更新する手法。

**理解深化：**
- **Prototypeメソッド:** `Book.prototype.toggleRead` を定義し、インスタンスごとにメソッドを複製せずメモリを節約する設計（各インスタンスが共通の親機能を参照する仕組み）。
- **データ駆動のDOM操作:** DOM（HTML）を直接操作・管理するのではなく、「データ（配列）」の状態を変更し、それを元に「描画（`displayBook`）」するという、MVCパターンの基礎となる考え方。

**トラブルシューティング：**
- **課題:** 削除ボタンを押した後、どの本を消すべきか特定する方法（インデックス依存からの脱却）。
- **解決:** 各Bookオブジェクト生成時にUUIDを付与。DOM生成時に `card.dataset.id = book.id` で紐付けを行い、削除時はそのIDを使って `myLibrary.filter` を実行することで、ズレ問題を根本解決した。

### 🔗 実装コード
- リポジトリ：未作成
- 主要コード：
```javascript
// プロトタイプによるメモリ効率の良いステータス変更
Book.prototype.toggleRead = function() {
  this.isRead = !this.isRead;
};

// UUIDとfilterを使った安全な削除ロジック
function removeBook(id) {
  myLibrary = myLibrary.filter(book => book.id != id);
  displayBook();
}

// データ属性とクロージャを活用したイベント紐付け
const deleteBtn = document.createElement('button');
deleteBtn.onclick = () => {
  removeBook(book.id); // 特定のIDを渡して削除関数を実行
};
```

### ⏭️ Next Action
- [ ] Factory Functions and the Module Pattern セクションの学習（目安：60分）
- [ ] グローバル変数（`myLibrary`）を隠蔽するため、モジュールパターンを用いてリファクタリングを行う。
- [ ] 初期データ（The Hobbit）が表示されないバグの修正（`addBookToLibrary`後に`displayBook`を呼び出す）。

